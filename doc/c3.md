# Capítulo 3: Produto

## 3.1 Implementação Técnica

### 3.1.1 Estrutura do Projeto

```
Car-Maintenance-M3/
│
├── api/                                    # API LoopBack 4
│   ├── src/
│   │   ├── models/                         # Modelos de dados
│   │   │   ├── customer.model.ts
│   │   │   ├── vehicle.model.ts
│   │   │   ├── workshop.model.ts
│   │   │   ├── service.model.ts
│   │   │   ├── appointment.model.ts
│   │   │   ├── maintenance.model.ts
│   │   │   └── appointment-service.model.ts
│   │   │
│   │   ├── controllers/                    # Controllers REST
│   │   │   ├── customer.controller.ts
│   │   │   ├── vehicle.controller.ts
│   │   │   ├── workshop.controller.ts
│   │   │   ├── service.controller.ts
│   │   │   ├── appointment.controller.ts
│   │   │   └── maintenance.controller.ts
│   │   │
│   │   ├── repositories/                   # Repositórios
│   │   │   ├── customer.repository.ts
│   │   │   ├── vehicle.repository.ts
│   │   │   ├── workshop.repository.ts
│   │   │   ├── service.repository.ts
│   │   │   ├── appointment.repository.ts
│   │   │   └── maintenance.repository.ts
│   │   │
│   │   ├── datasources/                    # Datasources
│   │   │   └── mysql.datasource.ts
│   │   │
│   │   ├── application.ts                  # Configuração da aplicação
│   │   ├── index.ts                        # Entry point
│   │   └── sequence.ts                     # Request sequence
│   │
│   ├── public/                             # Ficheiros estáticos
│   ├── package.json
│   ├── tsconfig.json
│   └── .env                                # Variáveis de ambiente
│
├── backoffice/                             # Cliente React-Admin
│   ├── src/
│   │   ├── resources/                      # Recursos CRUD
│   │   │   ├── customers/
│   │   │   │   ├── CustomerList.tsx
│   │   │   │   ├── CustomerEdit.tsx
│   │   │   │   ├── CustomerCreate.tsx
│   │   │   │   └── CustomerShow.tsx
│   │   │   ├── vehicles/
│   │   │   ├── workshops/
│   │   │   ├── services/
│   │   │   ├── appointments/
│   │   │   └── maintenances/
│   │   │
│   │   ├── providers/
│   │   │   └── dataProvider.ts             # Data provider customizado
│   │   │
│   │   ├── components/
│   │   │   ├── Dashboard.tsx
│   │   │   ├── Layout.tsx
│   │   │   └── Menu.tsx
│   │   │
│   │   ├── App.tsx
│   │   └── index.tsx
│   │
│   ├── public/
│   ├── package.json
│   └── .env
│
├── docker/
│   ├── docker-compose.yml
│   ├── api.Dockerfile
│   ├── backoffice.Dockerfile
│   └── mysql/
│       └── init.sql                        # Script de inicialização
│
├── postman/
│   └── CarMaintenance.postman_collection.json
│
├── doc/                                    # Documentação
│   ├── c1.md
│   ├── c2.md
│   ├── c3.md
│   ├── c4.md
│   └── images/
│
└── README.md
```

---

## 3.2 Desenvolvimento da API com LoopBack 4

### 3.2.1 Configuração Inicial

**Instalação do LoopBack CLI:**

```bash
npm install -g @loopback/cli
```

**Criação do projeto:**

```bash
lb4 app car-maintenance-api
cd car-maintenance-api
```

### 3.2.2 Datasource MySQL

**Ficheiro:** `src/datasources/mysql.datasource.ts`

```typescript
import { inject, lifeCycleObserver, LifeCycleObserver } from '@loopback/core';
import { juggler } from '@loopback/repository';

const config = {
  name: 'mysql',
  connector: 'mysql',
  url: '',
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_DATABASE || 'carmaintenance',
};

@lifeCycleObserver('datasource')
export class MysqlDataSource
  extends juggler.DataSource
  implements LifeCycleObserver
{
  static dataSourceName = 'mysql';
  static readonly defaultConfig = config;

  constructor(
    @inject('datasources.config.mysql', { optional: true })
    dsConfig: object = config
  ) {
    super(dsConfig);
  }
}
```

**Comando de criação:**

```bash
lb4 datasource mysql
```

### 3.2.3 Modelos

**Exemplo: Customer Model**

**Ficheiro:** `src/models/customer.model.ts`

```typescript
import { Entity, model, property, hasMany } from '@loopback/repository';
import { Vehicle } from './vehicle.model';

@model({
  settings: {
    mysql: {
      table: 'customers',
    },
  },
})
export class Customer extends Entity {
  @property({
    type: 'number',
    id: true,
    generated: true,
  })
  id?: number;

  @property({
    type: 'string',
    required: true,
    mysql: {
      columnName: 'name',
      dataType: 'varchar',
      dataLength: 100,
      nullable: 'N',
    },
  })
  name: string;

  @property({
    type: 'string',
    required: true,
    index: {
      unique: true,
    },
    mysql: {
      columnName: 'email',
      dataType: 'varchar',
      dataLength: 100,
      nullable: 'N',
    },
  })
  email: string;

  @property({
    type: 'string',
    required: true,
  })
  phone: string;

  @property({
    type: 'string',
  })
  address?: string;

  @property({
    type: 'date',
    defaultFn: 'now',
  })
  created_at?: Date;

  @property({
    type: 'date',
    defaultFn: 'now',
  })
  updated_at?: Date;

  @hasMany(() => Vehicle)
  vehicles: Vehicle[];

  constructor(data?: Partial<Customer>) {
    super(data);
  }
}
```

**Comandos de criação:**

```bash
lb4 model Customer
lb4 relation  # Para criar relações
```

### 3.2.4 Repositories

**Exemplo: Customer Repository**

**Ficheiro:** `src/repositories/customer.repository.ts`

```typescript
import { inject, Getter } from '@loopback/core';
import {
  DefaultCrudRepository,
  repository,
  HasManyRepositoryFactory,
} from '@loopback/repository';
import { MysqlDataSource } from '../datasources';
import { Customer, CustomerRelations, Vehicle } from '../models';
import { VehicleRepository } from './vehicle.repository';

export class CustomerRepository extends DefaultCrudRepository<
  Customer,
  typeof Customer.prototype.id,
  CustomerRelations
> {
  public readonly vehicles: HasManyRepositoryFactory<
    Vehicle,
    typeof Customer.prototype.id
  >;

  constructor(
    @inject('datasources.mysql') dataSource: MysqlDataSource,
    @repository.getter('VehicleRepository')
    protected vehicleRepositoryGetter: Getter<VehicleRepository>
  ) {
    super(Customer, dataSource);
    this.vehicles = this.createHasManyRepositoryFactoryFor(
      'vehicles',
      vehicleRepositoryGetter
    );
    this.registerInclusionResolver('vehicles', this.vehicles.inclusionResolver);
  }
}
```

**Comando de criação:**

```bash
lb4 repository
```

### 3.2.5 Controllers

**Exemplo: Customer Controller**

**Ficheiro:** `src/controllers/customer.controller.ts`

```typescript
import {
  Count,
  CountSchema,
  Filter,
  FilterExcludingWhere,
  repository,
  Where,
} from '@loopback/repository';
import {
  post,
  param,
  get,
  getModelSchemaRef,
  patch,
  put,
  del,
  requestBody,
  response,
} from '@loopback/rest';
import { Customer } from '../models';
import { CustomerRepository } from '../repositories';

export class CustomerController {
  constructor(
    @repository(CustomerRepository)
    public customerRepository: CustomerRepository
  ) {}

  @post('/customers')
  @response(201, {
    description: 'Customer model instance',
    content: { 'application/json': { schema: getModelSchemaRef(Customer) } },
  })
  async create(
    @requestBody({
      content: {
        'application/json': {
          schema: getModelSchemaRef(Customer, {
            title: 'NewCustomer',
            exclude: ['id'],
          }),
        },
      },
    })
    customer: Omit<Customer, 'id'>
  ): Promise<Customer> {
    return this.customerRepository.create(customer);
  }

  @get('/customers/count')
  @response(200, {
    description: 'Customer model count',
    content: { 'application/json': { schema: CountSchema } },
  })
  async count(@param.where(Customer) where?: Where<Customer>): Promise<Count> {
    return this.customerRepository.count(where);
  }

  @get('/customers')
  @response(200, {
    description: 'Array of Customer model instances',
    content: {
      'application/json': {
        schema: {
          type: 'array',
          items: getModelSchemaRef(Customer, { includeRelations: true }),
        },
      },
    },
  })
  async find(
    @param.filter(Customer) filter?: Filter<Customer>
  ): Promise<Customer[]> {
    return this.customerRepository.find(filter);
  }

  @get('/customers/{id}')
  @response(200, {
    description: 'Customer model instance',
    content: {
      'application/json': {
        schema: getModelSchemaRef(Customer, { includeRelations: true }),
      },
    },
  })
  async findById(
    @param.path.number('id') id: number,
    @param.filter(Customer, { exclude: 'where' })
    filter?: FilterExcludingWhere<Customer>
  ): Promise<Customer> {
    return this.customerRepository.findById(id, filter);
  }

  @patch('/customers/{id}')
  @response(204, {
    description: 'Customer PATCH success',
  })
  async updateById(
    @param.path.number('id') id: number,
    @requestBody({
      content: {
        'application/json': {
          schema: getModelSchemaRef(Customer, { partial: true }),
        },
      },
    })
    customer: Customer
  ): Promise<void> {
    await this.customerRepository.updateById(id, customer);
  }

  @put('/customers/{id}')
  @response(204, {
    description: 'Customer PUT success',
  })
  async replaceById(
    @param.path.number('id') id: number,
    @requestBody() customer: Customer
  ): Promise<void> {
    await this.customerRepository.replaceById(id, customer);
  }

  @del('/customers/{id}')
  @response(204, {
    description: 'Customer DELETE success',
  })
  async deleteById(@param.path.number('id') id: number): Promise<void> {
    await this.customerRepository.deleteById(id);
  }
}
```

**Comando de criação:**

```bash
lb4 controller
```

### 3.2.6 Relação Many-to-Many

Para implementar a relação m:n entre Appointments e Services:

```typescript
// appointment.model.ts
@model()
export class Appointment extends Entity {
  // ... outras propriedades

  @hasMany(() => Service, {
    through: { model: () => AppointmentService },
  })
  services: Service[];
}

// service.model.ts
@model()
export class Service extends Entity {
  // ... outras propriedades

  @hasMany(() => Appointment, {
    through: { model: () => AppointmentService },
  })
  appointments: Appointment[];
}

// appointment-service.model.ts
@model()
export class AppointmentService extends Entity {
  @property({
    type: 'number',
    id: true,
    required: true,
  })
  appointmentId: number;

  @property({
    type: 'number',
    id: true,
    required: true,
  })
  serviceId: number;

  @property({
    type: 'number',
    required: true,
  })
  price: number;
}
```

---

## 3.3 Desenvolvimento do Backoffice com React-Admin

### 3.3.1 Configuração Inicial

**Criação do projeto:**

```bash
npm create vite@latest backoffice -- --template react-ts
cd backoffice
npm install react-admin
```

**Dependências principais:**

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-admin": "^4.16.0",
    "@mui/material": "^5.14.0",
    "@mui/icons-material": "^5.14.0"
  }
}
```

### 3.3.2 Data Provider Customizado

**Ficheiro:** `src/providers/dataProvider.ts`

```typescript
import { fetchUtils } from 'react-admin';
import { stringify } from 'query-string';

const apiUrl = 'http://localhost:3000/api';
const httpClient = fetchUtils.fetchJson;

export const dataProvider = {
  getList: (resource: string, params: any) => {
    const { page, perPage } = params.pagination;
    const { field, order } = params.sort;

    const filter = {
      limit: perPage,
      skip: (page - 1) * perPage,
      order: `${field} ${order}`,
      where: params.filter,
    };

    const url = `${apiUrl}/${resource}?${stringify({
      filter: JSON.stringify(filter),
    })}`;

    return httpClient(url).then(({ headers, json }) => ({
      data: json,
      total: json.length, // LoopBack precisa de endpoint count separado
    }));
  },

  getOne: (resource: string, params: any) =>
    httpClient(`${apiUrl}/${resource}/${params.id}`).then(({ json }) => ({
      data: json,
    })),

  getMany: (resource: string, params: any) => {
    const filter = {
      where: { id: { inq: params.ids } },
    };
    const url = `${apiUrl}/${resource}?${stringify({
      filter: JSON.stringify(filter),
    })}`;
    return httpClient(url).then(({ json }) => ({ data: json }));
  },

  create: (resource: string, params: any) =>
    httpClient(`${apiUrl}/${resource}`, {
      method: 'POST',
      body: JSON.stringify(params.data),
    }).then(({ json }) => ({
      data: { ...params.data, id: json.id },
    })),

  update: (resource: string, params: any) =>
    httpClient(`${apiUrl}/${resource}/${params.id}`, {
      method: 'PUT',
      body: JSON.stringify(params.data),
    }).then(({ json }) => ({ data: json })),

  updateMany: (resource: string, params: any) => {
    return Promise.all(
      params.ids.map((id: any) =>
        httpClient(`${apiUrl}/${resource}/${id}`, {
          method: 'PUT',
          body: JSON.stringify(params.data),
        })
      )
    ).then((responses) => ({
      data: responses.map(({ json }) => json.id),
    }));
  },

  delete: (resource: string, params: any) =>
    httpClient(`${apiUrl}/${resource}/${params.id}`, {
      method: 'DELETE',
    }).then(({ json }) => ({ data: json })),

  deleteMany: (resource: string, params: any) => {
    return Promise.all(
      params.ids.map((id: any) =>
        httpClient(`${apiUrl}/${resource}/${id}`, {
          method: 'DELETE',
        })
      )
    ).then((responses) => ({
      data: responses.map(({ json }) => json.id),
    }));
  },
};
```

### 3.3.3 Recursos CRUD

**Exemplo: Customer Resource**

**Ficheiro:** `src/resources/customers/CustomerList.tsx`

```typescript
import {
  List,
  Datagrid,
  TextField,
  EmailField,
  DateField,
  EditButton,
  ShowButton,
} from 'react-admin';

export const CustomerList = () => (
  <List>
    <Datagrid rowClick='show'>
      <TextField source='id' />
      <TextField source='name' />
      <EmailField source='email' />
      <TextField source='phone' />
      <TextField source='address' />
      <DateField source='created_at' />
      <EditButton />
      <ShowButton />
    </Datagrid>
  </List>
);
```

**Ficheiro:** `src/resources/customers/CustomerCreate.tsx`

```typescript
import { Create, SimpleForm, TextInput, required, email } from 'react-admin';

export const CustomerCreate = () => (
  <Create>
    <SimpleForm>
      <TextInput source='name' validate={[required()]} fullWidth />
      <TextInput source='email' validate={[required(), email()]} fullWidth />
      <TextInput source='phone' validate={[required()]} />
      <TextInput source='address' multiline fullWidth />
    </SimpleForm>
  </Create>
);
```

**Ficheiro:** `src/resources/customers/CustomerEdit.tsx`

```typescript
import {
  Edit,
  SimpleForm,
  TextInput,
  required,
  email,
  DateField,
} from 'react-admin';

export const CustomerEdit = () => (
  <Edit>
    <SimpleForm>
      <TextInput source='id' disabled />
      <TextInput source='name' validate={[required()]} fullWidth />
      <TextInput source='email' validate={[required(), email()]} fullWidth />
      <TextInput source='phone' validate={[required()]} />
      <TextInput source='address' multiline fullWidth />
      <DateField source='created_at' />
      <DateField source='updated_at' />
    </SimpleForm>
  </Edit>
);
```

### 3.3.4 Aplicação Principal

**Ficheiro:** `src/App.tsx`

```typescript
import { Admin, Resource } from 'react-admin';
import { dataProvider } from './providers/dataProvider';
import { Dashboard } from './components/Dashboard';

import {
  CustomerList,
  CustomerEdit,
  CustomerCreate,
  CustomerShow,
} from './resources/customers';
import {
  VehicleList,
  VehicleEdit,
  VehicleCreate,
  VehicleShow,
} from './resources/vehicles';
import {
  WorkshopList,
  WorkshopEdit,
  WorkshopCreate,
} from './resources/workshops';
import { ServiceList, ServiceEdit, ServiceCreate } from './resources/services';
import {
  AppointmentList,
  AppointmentEdit,
  AppointmentCreate,
} from './resources/appointments';
import {
  MaintenanceList,
  MaintenanceEdit,
  MaintenanceCreate,
} from './resources/maintenances';

import PeopleIcon from '@mui/icons-material/People';
import DirectionsCarIcon from '@mui/icons-material/DirectionsCar';
import BuildIcon from '@mui/icons-material/Build';
import HomeRepairServiceIcon from '@mui/icons-material/HomeRepairService';
import EventIcon from '@mui/icons-material/Event';
import HistoryIcon from '@mui/icons-material/History';

function App() {
  return (
    <Admin dataProvider={dataProvider} dashboard={Dashboard}>
      <Resource
        name='customers'
        list={CustomerList}
        edit={CustomerEdit}
        create={CustomerCreate}
        show={CustomerShow}
        icon={PeopleIcon}
      />
      <Resource
        name='vehicles'
        list={VehicleList}
        edit={VehicleEdit}
        create={VehicleCreate}
        show={VehicleShow}
        icon={DirectionsCarIcon}
      />
      <Resource
        name='workshops'
        list={WorkshopList}
        edit={WorkshopEdit}
        create={WorkshopCreate}
        icon={BuildIcon}
      />
      <Resource
        name='services'
        list={ServiceList}
        edit={ServiceEdit}
        create={ServiceCreate}
        icon={HomeRepairServiceIcon}
      />
      <Resource
        name='appointments'
        list={AppointmentList}
        edit={AppointmentEdit}
        create={AppointmentCreate}
        icon={EventIcon}
      />
      <Resource
        name='maintenances'
        list={MaintenanceList}
        edit={MaintenanceEdit}
        create={MaintenanceCreate}
        icon={HistoryIcon}
      />
    </Admin>
  );
}

export default App;
```

---

## 3.4 Containerização com Docker

### 3.4.1 Docker Compose

**Ficheiro:** `docker-compose.yml`

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: car-maintenance-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: carmaintenance
      MYSQL_USER: caruser
      MYSQL_PASSWORD: carpassword
    ports:
      - '3306:3306'
    volumes:
      - mysql_data:/var/lib/mysql
      - ./docker/mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - car-maintenance-network
    healthcheck:
      test: ['CMD', 'mysqladmin', 'ping', '-h', 'localhost']
      timeout: 20s
      retries: 10

  api:
    build:
      context: ./api
      dockerfile: ../docker/api.Dockerfile
    container_name: car-maintenance-api
    restart: always
    ports:
      - '3000:3000'
    environment:
      NODE_ENV: production
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: caruser
      DB_PASSWORD: carpassword
      DB_DATABASE: carmaintenance
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - car-maintenance-network

  backoffice:
    build:
      context: ./backoffice
      dockerfile: ../docker/backoffice.Dockerfile
    container_name: car-maintenance-backoffice
    restart: always
    ports:
      - '3001:80'
    environment:
      VITE_API_URL: http://localhost:3000/api
    depends_on:
      - api
    networks:
      - car-maintenance-network

volumes:
  mysql_data:

networks:
  car-maintenance-network:
    driver: bridge
```

### 3.4.2 Dockerfile da API

**Ficheiro:** `docker/api.Dockerfile`

```dockerfile
# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/public ./public

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

### 3.4.3 Dockerfile do Backoffice

**Ficheiro:** `docker/backoffice.Dockerfile`

```dockerfile
# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# Stage 2: Production com Nginx
FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html

COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**Ficheiro:** `backoffice/nginx.conf`

```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://api:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 3.4.4 Script de Inicialização MySQL

**Ficheiro:** `docker/mysql/init.sql`

```sql
-- Criar as tabelas
CREATE TABLE IF NOT EXISTS customers (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  phone VARCHAR(20) NOT NULL,
  address VARCHAR(200),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Dados de exemplo
INSERT INTO customers (name, email, phone, address) VALUES
('João Silva', 'joao.silva@example.com', '+351 912345678', 'Rua Principal, 123'),
('Maria Santos', 'maria.santos@example.com', '+351 923456789', 'Av. Central, 456');

-- Repetir para outras tabelas...
```

### 3.4.5 Publicação no Docker Hub

```bash
# Build das imagens
docker build -t inf25dw1g33/car-maintenance-api:latest -f docker/api.Dockerfile ./api
docker build -t inf25dw1g33/car-maintenance-backoffice:latest -f docker/backoffice.Dockerfile ./backoffice

# Push para Docker Hub
docker push inf25dw1g33/car-maintenance-api:latest
docker push inf25dw1g33/car-maintenance-backoffice:latest
```

---

## 3.5 Funcionalidades do Sistema

### 3.5.1 Dashboard

O dashboard apresenta:

- Número total de clientes
- Número total de veículos
- Agendamentos pendentes
- Manutenções do mês
- Gráficos de estatísticas

### 3.5.2 Gestão de Clientes

- Listagem com pesquisa e filtros
- Criação de novos clientes com validação
- Edição de dados
- Visualização de veículos associados
- Eliminação com confirmação

### 3.5.3 Gestão de Veículos

- Listagem completa de veículos
- Filtros por marca, modelo, ano
- Criação com seleção de cliente
- Histórico de manutenções
- Agendamentos futuros

### 3.5.4 Gestão de Agendamentos

- Calendário de agendamentos
- Criação com seleção múltipla de serviços
- Estados (pendente, confirmado, concluído, cancelado)
- Notificações (planeado)

---

**Próximo:** [Capítulo 4 - Apresentação e Conclusões →](c4.md)

[← Capítulo 2: Recursos](c2.md) | [Voltar ao README](../README.md)
